<!DOCTYPE html>
<html lang="de">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Glossar</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.0/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-KyZXEAg3QhqLMpG8r+8fhAXLRk2vvoC2f3B09zVXn8CA5QIVfZOJ3BCsw2P0p/We" crossorigin="anonymous">
    <link rel="stylesheet" href="../css/main.css">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.0/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-U1DAWAznBHeqEIlVSCgzq+c9gqGAJn5c/t99JyeKa9xxaYpSvHU5awsuZVVFIhvj"
        crossorigin="anonymous"></script>
    <script src="https://kit.fontawesome.com/f4e8912340.js" crossorigin="anonymous"></script>
</head>

<body>
    <nav class="navbar navbar-expand-md navbar-dark bg-dark">
        <div class="container-fluid">
            <span class="navbar-brand mb-0 h1">ERA</span>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav"
                aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav">
                    <li class="nav-item">
                        <a class="nav-link" aria-current="page" href="/">Home</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link active" href="/html/glossar.html">Glossar</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <div class="container">
        <h1>Glossar</h1>
        <p>Bei diesem Glossar handelt es sich um eine Erweiterung meiner Notizen zur Klausurvorbereitung. Es ist sehr
            wahrscheinlich, dass verschiedenste Fehler/Ungenauigkeiten in den Definitionen vorkommen. Diese kann man
            gerne als Issue <a
                href="https://github.com/hertelukas/era/issues/new?assignees=&labels=glossar&template=fehler-im-glossar.md&title=%5BBEGRIFF%5D"
                target="_blank" rel="noopener noreferrer">hier</a> melden, oder man erstellt einen neuen Pull-Request.
        </p>
        <table class="table table-striped">
            <thead>
                <tr>
                    <th scope="col">Begriff</th>
                    <th scope="col">Definition</th>
                    <th scope="col">Vorteile</th>
                    <th scope="col">Nachteile</th>
                </tr>
            </thead>
            <tr>
                <td>
                    "Load/Store"-Architektur</td>
                <td>Auch Register-Register-Maschine genannt.
                    <ul>
                        <li>Speicherzugriffe explizit als Maschinenbefehle</li>
                        <li>Arithmetik nur aus Registern</li>
                        <li>Registerindirekte Adressierung mit 12bit oder Register Offset</li>
                        <li>Unterstützt Prädekrement/Postinkrement</li>
                    </ul>
                </td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td>Von-Neumann Architekturkonzept</td>
                <td>
                    <ol>
                        <li>Strukturunabhängigkeit des Rechners</li>
                        <li>4 Werke</li>
                        <li>Sequentiell, Befehle nacheinander gespeichert & ausgeführt</li>
                        <li>Binär</li>
                        <li>Programme & Daten in einem Speicher</li>
                        <li>Speicher besteht aus Zeilen fester Grösse</li>
                        <li>Sprünge möglich</li>
                    </ol>
                </td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td>Adressierungsarten</td>
                <td>
                    <ul>
                        <li>Direkte A.</li>
                        <li>Registerindirekte A.</li>
                        <li>Registerindirekt mit Dekr/Inkr</li>
                        <li>Registerindirekt mit Displacement</li>
                        <li>Indizierte A.</li>
                        <li>Indizierte A. mit Skalierungsfaktor</li>
                        <li>Befehlszähler-relative A.</li>
                        <li>Speicherindirekte A.</li>
                    </ul>
                </td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td><a href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit"
                        target="_blank">ASIC</a></td>
                <td><b>Application Specific Integrated Circuit</b> Eine spezialisierte VLSI für einen bestimmten Zweck
                </td>
                <td>
                    <ul>
                        <li>Schneller</li>
                        <li>Energieeffizienter</li>
                        <li>Kleiner</li>
                        <li>Strahlungsresistent</li>
                        <li>...</li>
                    </ul>
                </td>
                <td>
                    <ul>
                        <li>Aufwendige Entwicklung</li>
                        <li>Teuere Entwicklung</li>
                        <li>Nicht vielseitig einsetzbar</li>
                    </ul>
                </td>
            </tr>
            <tr>
                <td>Befehlszyklus</td>
                <td>
                    <ol>
                        <li>Befehl holen</li>
                        <li>Befehl holen</li>
                        <li>Dekodieren</li>
                        <li>Adresse evaluieren</li>
                        <li>Operand -> Rechnwerk</li>
                        <li>Befehl ausführen</li>
                        <li>In Accumulator/Register</li>
                        <li>BZ erhöhen</li>
                    </ol>
                </td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td>Behavioral Programming (HDL)</td>
                <td>Ähnlich sequentieller Programme. Beschreibt das Verhalten von Schaltungen.
                    Höchste Abstraktionsebene.</td>
                <td>
                    <ul>
                        <li>Einfach zu beschreiben/verstehen</li>
                    </ul>
                </td>
                <td>
                    <ul>
                        <li>Weniger Kontrolle</li>
                    </ul>
                </td>
            </tr>
            <tr>
                <td>Benutzermodus</td>
                <td>
                    <ul>
                        <li>Eingeschränkter Zugriff</li>
                        <li>Keine privilegierten Befehle wie z.B. Ein-/Ausgabe</li>
                        <li>Kein Zugriff auf Konfigurationsregister</li>
                    </ul>
                </td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td><a href="https://en.wikipedia.org/wiki/Endianness" target="_blank">Big-Endian</a></td>
                <td>Höchstes Byte wird an niedrigster Adresse gespeichert.
                    <p>
                    <h5>Beispiel</h5>
                    <b>0x01234567</b> wird folgend abgespeichert:
                    <table class="table table-sm table-striped">
                        <thead>
                            <tr>
                                <th scope="col">Adresse</th>
                                <th scope="col">Wert</th>
                            </tr>
                        </thead>
                        <tr>
                            <td>n+3</td>
                            <td>67</td>
                        </tr>
                        <tr>
                            <td>n+2</td>
                            <td>45</td>
                        </tr>
                        <tr>
                            <td>n+1</td>
                            <td>23</td>
                        </tr>
                        <tr>
                            <td>n</td>
                            <td>01</td>
                        </tr>
                    </table>
                    </p>
                </td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td><a href="https://en.wikipedia.org/wiki/Endianness" target="_blank">Little-Endian</a></td>
                <td>Höchstes Byte steht an höchster Adresse. Wird von Intel verwendet und wird deutlich häufiger
                    verwendet.
                    <p>
                    <h5>Beispiel</h5>
                    <b>0x01234567</b> wird folgend abgespeichert:
                    <table class="table table-sm table-striped">
                        <thead>
                            <tr>
                                <th scope="col">Adresse</th>
                                <th scope="col">Wert</th>
                            </tr>
                        </thead>
                        <tr>
                            <td>n+3</td>
                            <td>01</td>
                        </tr>
                        <tr>
                            <td>n+2</td>
                            <td>23</td>
                        </tr>
                        <tr>
                            <td>n+1</td>
                            <td>45</td>
                        </tr>
                        <tr>
                            <td>n</td>
                            <td>67</td>
                        </tr>
                    </table>
                    </p>
                </td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td><a href="https://en.wikipedia.org/wiki/Device_file#Block_devices" target="_blank"
                        rel="noopener noreferrer">Block Devices</a></td>
                <td>
                    <ul>
                        <li>Abstraktion im BS: Blöcke von Daten</li>
                        <li>Benutzer kann auf einzelne Daten zugriefen</li>
                        <li>Üblicherweise mit Dateisystem verbunden</li>
                        <li>z.B. Festplattenspeicher</li>
                    </ul>
                </td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td><a href="https://en.wikipedia.org/wiki/Branch_predictor" target="_blank"
                        rel="noopener noreferrer">Branch Prediction</a></td>
                <td>Vorhersage, ob Sprung genommen wird
                    Bei inkorrekter Vorhersage muss Pipeline neu aufgesetzt werden -> teuer
                </td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td>Cache Directory Protokolle</td>
                <td>Zentrales Verzeichnis, welches übersicht von Kopien in Caches hat. Heutiger Standard, kein Snooping
                    mehr.</td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td>Cache Index Bits</td>
                <td>Bestimmt die Cachezeile, in der Adresse sein kann.
                    32 Byte pro Cachezeile, Cache Grösse 32 KiB -> 1024 Cachezeilen -> 10 bit Index

                    Bei Cache Sets, wird das Set beschrieben
                </td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td>Cache Offset Bits</td>
                <td>Unterste Bits, bestimmen byte(?) index in einer Zeile.
                    32 Byte pro Cachezeile -> 5bit
                </td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td><a href="https://en.wikipedia.org/wiki/Bus_snooping" target="_blank" rel="noopener noreferrer">Cache
                        Snooping</a></td>
                <td>Gemeinsamer Bus zwischen Caches, alle Teilnehmer hören mit.
                    <ul>
                        <li>Teilnehmer passen laufend Cache-Inhalt an</li>
                        <li>MSI oder MESI Automat</li>
                    </ul>
                </td>
                <td>
                    <ul>
                        <li>Einfach zu implementieren</li>
                    </ul>
                </td>
                <td>
                    <ul>
                        <li>Busse skalieren schlecht</li>
                    </ul>
                </td>
            </tr>
            <tr>
                <td>Cache Tag Bit</td>
                <td>Oberste Bits, beschreiben welche Daten in Cachezeile sind</td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td>Capacity Cache Misses</td>
                <td>Der Speicherblock wäre auch verdrängt worden, wenn der Cache vollassoziativ wäre.</td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td><a href="https://en.wikipedia.org/wiki/Complex_instruction_set_computer" target="_blank">CISC</a>
                </td>
                <td><b>Complex Instruction Set Computer</b> Befehlssatz mit vielen Instruktionen, steht im Gegensatz zu
                    RISC.
                    Wird durch Mikroprogramme
                    realisiert.</td>
                <td>
                    <ul>
                        <li>Einfach Programmierbar</li>
                        <li>Geringer Speicherbedarf</li>
                    </ul>
                </td>
                <td>
                    <ul>
                        <li>Komplexe & langsame Implementierung</li>
                        <li>Komplexe & langsame Dekodierung</li>
                        <li>u.U ungenutzte Instruktionen</li>
                    </ul>
                </td>
            </tr>
            <tr>
                <td><a href="https://en.wikipedia.org/wiki/CMOS" target="_blank" rel="noopener noreferrer">CMOS</a></td>
                <td>

                    <div class="card mb-3" style="max-width: 540px;">
                        <div class="row g-0">
                            <div class="col-md-4">
                                <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/2f/CMOS_inverter.svg/1024px-CMOS_inverter.svg.png"
                                    class="img-fluid rounded-start" alt="CMOS Inverter">
                            </div>
                            <div class="col-md-8">
                                <div class="card-body">
                                    <p class="card-text"> <b>Complementary metal-oxide semiconductor</b> Besteht aus NPN
                                        und PNP Transistor. In der Abbildung ist ein CMOS Inverter zu sehen.</p>
                                    <p class="card-text"><small class="text-muted"><a
                                                href="https://commons.wikimedia.org/wiki/File:CMOS_inverter.svg">Abaddon1337</a>,
                                            <a href="https://creativecommons.org/licenses/by-sa/3.0">CC BY-SA 3.0</a>,
                                            via Wikimedia Commons</small>
                                    </p>
                                </div>
                            </div>
                        </div>
                    </div>
                </td>
                <td>
                    <ul>
                        <li>0 und 1 geschaltet</li>
                        <li>weniger Verlustleistung</li>
                        <li>weniger Hitzeentwicklung</li>
                        <li>weniger Störanfällig</li>
                    </ul>
                </td>
                <td></td>
            </tr>
            <tr>
                <td>Compulsory (cold) Cache Misses</td>
                <td>Erster Zugriff auf eine Adresse, nicht zu vermeiden</td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td>Conflict Cache Misses</td>
                <td>Speicherblock wurde verdrängt, da ein andere Block auf das gleiche Cache Set abgebildet wurde.</td>
                <td>
                    <ul>
                        <li>Unter Umständen vermeidbar</li>
                    </ul>
                </td>
                <td></td>
            </tr>
            <tr>
                <td><a href="https://en.wikipedia.org/wiki/Complex_programmable_logic_device" target="_blank"
                        rel="noopener noreferrer">CPLD</a></td>
                <td><b>Complex programmable logic device</b> Ein CPLD besteht aus mehreren SPLD Arrays welche
                    programmierbar miteinander verbunden sind.
                </td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td>Dataflow Programming (HDL)</td>
                <td>Boolesche Gleichungen, hierbei werden Automaten (Übergangsdiagramme) implementiert. Liegt zwischen
                    Behavioral und Structural.
                </td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td><a href="https://en.wikipedia.org/wiki/Binary_decoder" target="_blank"
                        rel="noopener noreferrer">Decoder</a></td>
                <td>
                    <p>n Eingänge zu 2<sup>n</sup> einzigartigen Ausgängen.
                        Nur ein Ausgang wird dabei auf 1 gesetzt.</p>

                    <div class="card" style="width: 20rem;">
                        <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/fc/Decoder_Example.svg/440px-Decoder_Example.svg.png"
                            class="card-img-top" alt="...">
                        <div class="card-body">
                            <p class="card-text">Ein 2 zu 4 Bit Decoder <br><small class="text-muted"><a
                                        href="https://commons.wikimedia.org/wiki/File:Decoder_Example.svg">BlueJester0101</a>,
                                    <a href="http://creativecommons.org/licenses/by-sa/3.0/">CC BY-SA 3.0</a>, via
                                    Wikimedia Commons</small></p>
                        </div>
                    </div>
                </td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td>Dennard Scaling</td>
                <td>Besagt, dass mit kleineren Transistoren auch die nötige Stromleistung zurück geht.
                    Endete ca 2005, da Prozessoren nicht mehr mehr Leistung benötigen, man setzt auf mehrere Kerne.
                </td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td>Direct I/O</td>
                <td>
                    <ul>
                        <li>Spezielle Befehle im Befehlssatz</li>
                        <li>Separate Adressen für I/O Geräte</li>
                        <li>Separate Bus für I/O Operationen</li>
                        <li>Prozessor kontrolliert E/A, wartet auf Daten</li>
                    </ul>
                </td>
                <td>
                    <ul>
                        <li>Schnell</li>
                    </ul>
                </td>
                <td>
                    <ul>
                        <li>Verschwendete Ressourcen</li>
                    </ul>
                </td>
            </tr>
            <tr>
                <td>Direct Mapped Cache</td>
                <td>Jede Adresse passt zu einer Cachezeile, die Index-Bits bestimmen die Lage der Daten im Cache.
                </td>
                <td>
                    <ul>
                        <li>Einfach zu berechnen, dadurch schnell</li>
                        <li>Einfach zu bauen</li>
                    </ul>
                </td>
                <td>
                    <ul>
                        <li>Unflexibel</li>
                        <li>Häufige Verdrängung von Cachezeilen</li>
                    </ul>
                </td>
            </tr>
            <tr>
                <td>DMA</td>
                <td><b>Direct Memory Access</b>
                    <ul>
                        <li>Prozessor beschreibt Transfer</li>
                        <li>Unabhängiger Kontroller führt ihn aus</li>
                        <li>Interrupt bei Abschluss</li>
                    </ul>
                </td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td><a href="https://en.wikipedia.org/wiki/Dynamic_random-access_memory" target="_blank"
                        rel="noopener noreferrer">DRAM</a></td>
                <td><b>Dynamic Random Access Memory </b>

                    <p>
                        Kondensator mit Information, hat eine Auswahlleitung und eine Bitleitung. Erfordert
                        regelmässigen DRAM Refresh.
                    </p>

                    <ul>
                        <li> Schreiben: Auswahlsignal setzen, 0 oder 1 an Bitleitung, lädt oder entlädt den Kondensator.
                        </li>
                        <li> Lesen: Auswahlsignal setzen, Wert zwischen 0 und 1 auf Bitleitung. Wenn 0 lädt sich der
                            Kondensator, Bitleitung geht auf 0 und umgekehrt.
                        </li>
                    </ul>
                </td>
                <td>
                    <ul>
                        <li>Einfach aufgebaut</li>
                        <li>Kann gross und günstig hergestellt werden</li>
                    </ul>
                </td>
                <td>
                    <ul>
                        <li>Grosser aktiver und passiver Energiebedarf</li>
                        <li>Langsamer Zugriff</li>
                    </ul>
                </td>
            </tr>
            <tr>
                <td><a href="https://en.wikipedia.org/wiki/Encoder_(digital)" target="_blank"
                        rel="noopener noreferrer">Encoder</a></td>
                <td>
                    <p>2<sup>n</sup> Eingänge werden binär kodiert auf n Ausgänge, so lange nur ein Eingang an ist.
                    </p>

                    <div class="card" style="width: 20rem;">
                        <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/4/4b/Encoder_diagram.svg/2880px-Encoder_diagram.svg.png"
                            class="card-img-top" alt="...">
                        <div class="card-body">
                            <p class="card-text">Ein 4 zu 2 Bit Decoder <br><small class="text-muted"><a
                                        href="https://commons.wikimedia.org/wiki/File:Encoder_diagram.svg">No
                                        machine-readable author provided. Booyabazooka assumed (based on copyright
                                        claims).</a>, <a href="http://creativecommons.org/licenses/by-sa/3.0/">CC BY-SA
                                        3.0</a>, via Wikimedia Commons</small></p>
                        </div>
                    </div>
                </td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td><a href="https://en.wikipedia.org/wiki/Ethernet" target="_blank"
                        rel="noopener noreferrer">Ethernet</a></td>
                <td>Am weitesten verbreitete Familie von Netztechnologien
                    <ul>
                        <li> Früher Shared Medium -> Quasi ein Bus </li>
                        <li> Heute Point to Point (Switched Network) </li>
                    </ul>
                </td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td>Exceptions</td>
                <td>
                    <ul>
                        <li>Ausgelöst von einer Operation im Programm (von innen)</li>
                        <li>Synchron</li>
                        <li>Beispiel: Nicht erlaubte Befehle (z.B. divide by zero)</li>
                    </ul>
                </td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td>Exklusiver Cache</td>
                <td>Jeder Speicherblock existiert nur einmal in der gesamnten Cachehierarchie. Häufig bei AMD verwendet.
                </td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td><a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array" target="_blank"
                        rel="noopener noreferrer">FPGA</a></td>
                <td><b>Field Programmable Gate Array</b>
                    <ul>
                        <li>Emulation von beliebigen Schaltungen</li>
                        <li>Einfacher als CPLDs</li>
                    </ul>
                </td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td>Gründe für Moduswechsel</td>
                <td>
                    <ul>
                        <li>durch speziellen Befehl </li>
                        <li>durch Interrupts/Exceptions</li>
                    </ul>
                </td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td>Hardware Prefetching</td>
                <td>Hardware untersucht Zugriffsadressen -> Erkennt Muster -> Liest zukünftige Daten.
                    Beispiel: Prefetch Folgezeile oder Strided Prefetcher</td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td>Hardware Thread</td>
                <td>
                    <ul>
                        <li>Ausführungseinheit in Hardware mit BZ</li>
                        <li>Getrennte Registersätze</li>
                        <li>Führt eine Programmsequenz aus</li>
                    </ul>

                    Wird oft auch Kern genannt
                </td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td><a href="https://en.wikipedia.org/wiki/Hardware_description_language" target="_blank"
                        rel="noopener noreferrer">HDL</a></td>
                <td><b>Hardware Description Language</b> Beschreibung einzelner Komponenten für die Entwicklung von
                    FPGAs
                </td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td>Inklusiver Cache</td>
                <td>Alle Speicherblöcke sind auch in dem nächst grösseren Cache enthalten. Häufig bei Intel verwendet.
                </td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td>Interrupt-driven I/O</td>
                <td>Prozessor löst Zugriff aus, E/A arbeitet alleine, Abschluss wird durch Interrupt signalisiert. Steht
                    im Gegensatz zu Direct I/O</td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td>Interrupts</td>
                <td>
                    <ul>
                        <li>Erlauben dem Prozessor auf externe( Tastaur z.B.), asynchrone Ereignisse zu reagieren</li>
                        <li>Können ignoriert werden</li>
                    </ul>
                </td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td><a href="https://en.wikipedia.org/wiki/Lookup_table" target="_blank"
                        rel="noopener noreferrer">LUT</a></td>
                <td><b>Lookup Table</b>
                    Zentrales Element eines Logikblocks in einem FPGA.
                    <ul>
                        <li>3-6bit Eingang</li>
                        <li>1 bit Ausgang</li>
                        <li>Beliebige Schaltung</li>
                        <li>Optional mit Flipflop</li>
                    </ul>

                    Kann z.B. als SRAM realisiert werden.
                </td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td><a href="https://en.wikipedia.org/wiki/Mealy_machine" target="_blank"
                        rel="noopener noreferrer">Mealy Automat</a></td>
                <td>Ein deterministischer endlicher Automat, dessen Ausgabe von seinem Zustand und seiner Eingabe
                    abhängt.</td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td>Mehrkern Architektur</td>
                <td>Mehrere HW Threads in einem System
                    <ul>
                        <li>getrennte Kerne</li>
                        <li>Replikation Leit & Rechenwerk</li>
                        <li>Gemeinsamer Speicher</li>
                        <li>Meist gemeinsames E/A Werk</li>
                        <li>Voller Speed-Up (Gegensatz zu SMT)</li>
                    </ul>
                </td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td>Memory Mapped I/O</td>
                <td>
                    <ul>
                        <li>Ansprechen der Geräte über Speicherbereiche</li>
                        <li>Speicher Teil des normalen Speicherbereichs</li>
                        <li>Kontrolliert duch virtuelle Speicherverwaltung</li>
                        <li>Heutiger Standard</li>
                    </ul>
                </td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td>Memory Mountain</td>
                <td>
                    <ul>
                        <li>Umso grösser der Speicher -> Umso langsamer</li>
                        <li>Umso grösser die Strides -> Umso langsamer</li>
                    </ul>
                </td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td>Mengenassoziativer Cache</td>
                <td>
                    <ul>
                        <li>Jede Adresse kann auf einen Teil der Cache Zeilen abgebildet werden</li>
                        <li>Mehrere Cache-Sets / Reduzierte Zahl von Index bits</li>
                    </ul>
                    Beispiel: 4-way associative = 4 Zeilen pro Cacheset
                </td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td><a href="https://en.wikipedia.org/wiki/MESI_protocol" target="_blank" rel="noopener noreferrer">MESI
                        Protokoll</a></td>
                <td>MSI, aber mit Exclusive Zustand. <br>
                    Exclusive: Wert in einem Cache, unverändert</td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td>MIMD</td>
                <td><b>Multiple Instruction Multiple Data</b>
                    n Rechenwerke, n Leitwerke <br>
                    -> Parallele Systeme
                    <ul>
                        <li>Mehrere HW Threads, prinzipiell unkoordiniert, keine direkten abhängigkeiten, parallele
                            Ausführung</li>
                        <li>Gemeinsamer Speicher, sonst getrennte Maschinen</li>
                    </ul>
                </td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td><a href="https://en.wikipedia.org/wiki/Memory_management_unit" target="_blank"
                        rel="noopener noreferrer">MMU</a></td>
                <td><b>Memory management unit</b>
                    Separate Hardware auf der CPU, welche virtuelle Adressen via LUT in Physikalische übersetzt.</td>
            </tr>
            <tr>
                <td><a href="https://en.wikipedia.org/wiki/Moore_machine" target="_blank"
                        rel="noopener noreferrer">Moore Automat</a></td>
                <td>Ein endlicher Automat, dessen Ausgabe ausschließlich von seinem Zustand abhängt.</td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td><a href="https://en.wikipedia.org/wiki/MSI_protocol" target="_blank" rel="noopener noreferrer">MSI
                        Protokoll</a></td>
                <td>Jede Cachezeile muss ihren Status mitverfolgen.
                    <ul>
                        <li>Modified: Cachezeile lokal geändert, Speicher nicht koheränt</li>
                        <li>Shared: Wert in mindestens einem Cache, kohärent</li>
                        <li>Invalid: Cacheblock nicht gültig oder veraltet</li>
                    </ul>
                </td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td><a href="https://en.wikipedia.org/wiki/Multiplexer" target="_blank"
                        rel="noopener noreferrer">Multiplexer</a></td>
                <td>Wid genutzt um Daten auszuwählen. Es wird anhand eines Selector- Eingangs ein Eingang ausgewählt und
                    dieser weitergeleitet zum Ausgang.
                    <br>
                    <div class="card" style="width: 20rem;">
                        <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/1/16/Multiplexer2.svg/2880px-Multiplexer2.svg.png"
                            class="card-img-top" alt="Multiplexer">
                        <div class="card-body">
                            <p class="card-text">2-zu-1 Multiplexer. Entspricht einem kontrollierten Switch.<br><small class="text-muted"><a
                                        href="https://commons.wikimedia.org/wiki/File:Multiplexer2.svg">CaesarIII</a>,
                                    <a href="https://creativecommons.org/licenses/by-sa/3.0">CC BY-SA 3.0</a>, via
                                    Wikimedia Commons</small></p>
                        </div>
                    </div>
                </td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td>Multithreading</td>
                <td>Mehrere HW Threads in einem Prozessorkern.
                    <ul>
                        <li>Einzelner BZ und Register</li>
                        <li>Ressourcen geteilt</li>
                        <li>Umschalten nach x Takten</li>
                        <li>Meist Fork/Join (Master startet einen neuen Thread) (siehe Java Threads)</li>
                    </ul>
                </td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td>NAND und NOR Flash</td>
                <td>NAND
                    - schneller, kleiner
                    - Gut für Speicher
                    - Zugriff nur über Blöcke
                    - NAND SSDs für kleine Zugriffe mit NOR Seitentabellen realisiert
                    - Begrenzte Anzahl Löschvorgänge
                    NOR
                    - Zuverlässiger, Einzelzugriff
                    - Gut für BIOS, Boot Medien</td>
            </tr>
            <tr>
                <td>Nebenläufige und Parallele Programme</td>
                <td>Nebenläufig
                    - Getrennte Aufgaben
                    - Lose Kooperation
                    - Bsp. GUI, E/A

                    Parallel
                    - Gemeinsame Aufgabe
                    - Enge Kopplung
                    - Bsp. numerische Simulation, Suchalgorithmen</td>
            </tr>
            <tr>
                <td>NIC</td>
                <td>Network Interface Card</td>
            </tr>
            <tr>
                <td>Non-uniform Memory Access</td>
                <td>- Speicher ist verteilt über mehrere Kerne
                    - Inter-Kern Netzwerk
                    - Standard, da Controller im Prozessor
                    -> Schnelle lokale Zugriffe
                    -> Datenplatzierung wichtig</td>
            </tr>
            <tr>
                <td>NPN Transistor</td>
                <td>NPN ist ein Arbeitskontakt -> Leitend, falls Strom anliegt</td>
            </tr>
            <tr>
                <td>Out-Of-Order</td>
                <td>Auch dynamisches Scheduling genannt.
                    Unabhängige Instruktionen können ausgeführt werden, obwohl vorherige Operationen blockiert sind.
                    Trotzdem transparent</td>
            </tr>
            <tr>
                <td>PAL / GAL</td>
                <td>Programmable/General Array Logic
                    UND programmierbar
                    ODER fest

                    PAL -> Non-Volatile
                    GAL -> Volatile</td>
            </tr>
            <tr>
                <td>Physically Indexed Cache</td>
                <td>Cache nach MMU, Cache arbeitet mit physikalischen Adressen
                    + Überlebt Prozesswechsel
                    + Gut für grosse Caches
                    - Jeder Zugriff durch MMU</td>
            </tr>
            <tr>
                <td>Pipeline Control Hazard</td>
                <td>Verursacht durch Sprünge, da Befehl unbekannt</td>
            </tr>
            <tr>
                <td>Pipeline Data Hazard</td>
                <td>Datenabhängigkeiten nicht erfüllt</td>
            </tr>
            <tr>
                <td>Pipeline Structural Hazard</td>
                <td>Ressourcenprobleme in der Hardware</td>
            </tr>
            <tr>
                <td>Pipelining</td>
                <td>- Bearbeitung eines Objekts in Teilschritte zerlegt, sequentiell ausgeführt
                    - Die Phasen werden für verschiedene Objekte überlappend abgearbeitet
                    - Software oder Hardware</td>
            </tr>
            <tr>
                <td>PLA</td>
                <td>Programmable Logic Array
                    Für DNFs, UND gefolgt von ODER, beides programmierbar</td>
            </tr>
            <tr>
                <td>PLD</td>
                <td>Programmable Logic Device</td>
            </tr>
            <tr>
                <td>Probeme bei OoO Execution</td>
                <td>- Erhöhte Buchhaltunkgskomplexität
                    - Speicher muss konsistent gehalten werden -> Reorder Buffers</td>
            </tr>
            <tr>
                <td>PROM</td>
                <td>Programmable Read-Only Memory
                    UND fest
                    ODER programmierbar

                    EPROM -> Erasable PROM, mit UV Licht
                    EEPROM -> Electrcially EPROM</td>
            </tr>
            <tr>
                <td><a href="https://en.wikipedia.org/wiki/Reduced_instruction_set_computer" target="_blank">RISC</a>
                </td>
                <td>Reduced Instruction Set Computer. Hoch optimierter, minimalistischer Befehlssatz mit nur wenig
                    unterschiedlichen Instruktionen. Steht
                    im Gegensatz zu CISC. Wird durch feste Vertratungen realisiert.</td>
                <td>
                    <ul>
                        <li>Einfache Implementierung</li>
                        <li>Effizeinte Implementierung</li>
                        <li>Schnelle Implementierung</li>
                    </ul>
                </td>
                <td>
                    <ul>
                        <li>Schwierigere Programmierbarkeit (Wird aber durch Compiler abstrahiert)</li>
                    </ul>
                </td>
            </tr>
            <tr>
                <td>ROM</td>
                <td>Read Only Memory
                    UND fest
                    ODER fest</td>
            </tr>
            <tr>
                <td>SIMD</td>
                <td>Single Instruction Multiple Data
                    n Rechenwerke, 1 Leitwerk

                    -> Pipelines, Vectors, GPUs (Moderne GPUs sind MIMD, mehrere extreme SIMD Blöcke)
                    Mehrere Daten werden durch einen Maschinenbefehl geleitet</td>
            </tr>
            <tr>
                <td>Simultaneous Multithreading (SMT)</td>
                <td>Gleichzeitige Nutzung von Ressourcen, passt zu OoO und Superskalarität</td>
            </tr>
            <tr>
                <td>SISD</td>
                <td>Single Instruction Single Data
                    1 Rechenwerk, 1 Leitwerk

                    -> Seq. Verarbeitung von Neumann</td>
            </tr>
            <tr>
                <td>Software Prefetching</td>
                <td>Explizite Instruktionen
                    + Unregelmässige Zugriffe können verbessert werden
                    - Benötigt Codeänderungen

                    Generell ist Software Prefetching nicht blockierend und erzeugt keine Ausnahmen</td>
            </tr>
            <tr>
                <td>Spin-Locks</td>
                <td>Busy waiting -> Siehe EIDI</td>
            </tr>
            <tr>
                <td>SPLD</td>
                <td>simple programmable logic device
                    Schaltnetz aus einem UND und einem ODER Array. Beide evtl. programmierbar</td>
            </tr>
            <tr>
                <td>SRAM</td>
                <td>Static Random Access Memory

                    Nutzung in Register & Caches
                    Prinzip ähnlich zu Latch.
                    Schreiben: Bit auf 1, Nicht Bit auf 0, Select auf 1, Inverter pegeln sich ein
                    Lesen: Bit auf 1, Nicht Bit auf 1, Inverter ziehen somit einen Ausgang auf 0, Spannungsabfall wird
                    gemessen</td>
                <td></td>
                <td>
                    <ul>
                        <li>Relativ gross & teuer</li>
                        <li>Grosser Energiebedarf wenn aktiv</li>
                    </ul>
                </td>
            </tr>
            <tr>
                <td>Stream Devices</td>
                <td>- Abstraktion im BS: Reihe/Strom von Bytes
                    - Zugriff meist sequentiell
                    - z.B. Tastatur, Serielle Schnittstellen</td>
            </tr>
            <tr>
                <td>Structural Programming (VHDL)</td>
                <td>Verbundenen einzelne Komponenten

                    + Volle Kontrolle
                    - Aufwendig</td>
            </tr>
            <tr>
                <td>Superskalarprinzip</td>
                <td>Ein superskalarer Prozessor verfügt im Vergleich zu einem Prozessor mit sequentieller Pipeline über
                    die n-fache Anzahl von Funktionseinheiten, Datenpfaden, Dekodierern, etc. -> n Befehle gleichzeitig
                    ausführen</td>
            </tr>
            <tr>
                <td>Systemmodus</td>
                <td>• Voller (=privilegierter) Zugriff auf alle Rechnerkomponenten
                    • Für das Betriebssystem</td>
            </tr>
            <tr>
                <td>Thread vs Prozess</td>
                <td>Threads sind eng gekoppelt
                    - Gemeinsamer Adressraum
                    - Schnelle Umschaltung
                    - Gemeinsame Ressourcen (Dateien...)

                    Prozesse sind lose gekoppelt
                    - Getrennte Adressräume
                    - Bessere Isolierung</td>
            </tr>
            <tr>
                <td>TLB</td>
                <td>Translation Lookaside Buffer - small cache of page table entries in the MMU used to speed up address
                    translation</td>
            </tr>
            <tr>
                <td>Uniform Memory Access (UMA)</td>
                <td>- Zentraler gemeinsamer Speicher
                    - Zugriffe haben gleiche Latenz (ausser durch Caches)
                    - Busse oder Crossbars</td>
            </tr>
            <tr>
                <td>Unterschied Pipelining und Superskalarität</td>
                <td>Pipelining: Mehrere verschiedene Stufen gleichzeitig
                    Superskalar: Mehrere gleiche Einheiten gleichzeitig

                    -> Beide erlauben Parallelität, ergänzen sich</td>
            </tr>
            <tr>
                <td>Virtually Indexed Cache</td>
                <td>Cache vor MMU, Cache arbeitet also mit virtuellen Adressen
                    + Direkter Zugang zu Cache ohne Übersetzung
                    + Gut für kleine Caches
                    - Mehrere Prozesse verwenden die gleichen virtuellen Adressen -> Cache löschen bei Prozesswechsel /
                    Tag + PID</td>
            </tr>
            <tr>
                <td>VLIW</td>
                <td>Very Long Instruction Word
                    Mehrere Instruktionen in einem Befehl, spezielle Prozessoren
                    + Explizite Abhängigkeiten -> Einfachere Hardware
                    + Explizites Scheduling -> Einfachere Hardware
                    - Komplexe, nicht kompatible ISAs
                    - Beruht auf Fähigkeiten des Compilers</td>
            </tr>
            <tr>
                <td>VLSI</td>
                <td>Very-large-scale integration is a manufacturing technique by which many thousands of transistors are
                    combined into a single chip.</td>
            </tr>
            <tr>
                <td>Volatile</td>
                <td>Erneut Programmierbar</td>
            </tr>
            <tr>
                <td>Voll assoziativer Cache</td>
                <td>- Jede Adresse kann auf jede Cache Zeile abgebildet werden
                    - Nur ein "Cache Set"
                    - Keine Index bits
                    - Grösste Flexibilität
                    - Grösse Komplexität</td>
            </tr>
            <tr>
                <td>Vor und Nachteile GPU</td>
                <td>+ Reduziert die Komplexität des Prozessors
                    + Erhöht Energieeffizienz
                    - Verrignerte Softwareflexibilität (Muss SIMD nutzen)
                    - Zusätzlicher Programmieraufwand</td>
            </tr>
            <tr>
                <td>Vorteile FPGA vs ASIC</td>
                <td>- Rekonfigurierbar
                    - Preis
                    - "Time to Market"</td>
            </tr>
            <tr>
                <td>Vorteile FPGA vs CPU</td>
                <td>- Geschwindigkeit
                    - Durchsatz
                    - Vorhersagbarkeit</td>
            </tr>
            <tr>
                <td>Vorteile OoO Execution</td>
                <td>- Bessere Nutzung der Ressourcen
                    - Bessere Nutzung von Parallelität
                    - Möglichkeit mehrere gleiche Befehle anzustossen</td>
            </tr>
            <tr>
                <td>Vorteile SRAM</td>
                <td>- Behält Wert solange Strom
                    - Sehr schnell (1 - 30 ns)
                    - Unempfindlich</td>
            </tr>
            <tr>
                <td>Vorteile und Nachteile von misaligned data</td>
                <td>Vorteile:
                    • Lückenlose Nutzung des Speichers bei Mischung verschiedener Datenformate
                    • Bessere Kompatibilität zu älteren ISAs
                    Nachteile:
                    • Ggf. zusätzliche Speicherzugriffe notwendig
                    • Höherer Hardware-Aufwand erforderlich</td>
            </tr>
            <tr>
                <td>Yielding Locks</td>
                <td>Falls Lock vergeben, gebe Thread ab</td>
            </tr>
        </table>
    </div>


    <footer class="footer">
        <span class="text-muted">Contribute on <a href="https://github.com/hertelukas/era" target="_blank"
                rel="noopener noreferrer"> <i class="fab fa-github"></i></a></span>
    </footer>
</body>

</html>