<!DOCTYPE html>
<html lang="de">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Glossar</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.0/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-KyZXEAg3QhqLMpG8r+8fhAXLRk2vvoC2f3B09zVXn8CA5QIVfZOJ3BCsw2P0p/We" crossorigin="anonymous">
    <link rel="stylesheet" href="../css/main.css">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.0/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-U1DAWAznBHeqEIlVSCgzq+c9gqGAJn5c/t99JyeKa9xxaYpSvHU5awsuZVVFIhvj"
        crossorigin="anonymous"></script>
    <script src="https://kit.fontawesome.com/f4e8912340.js" crossorigin="anonymous"></script>
</head>

<body>
    <nav class="navbar navbar-expand-md navbar-dark bg-dark">
        <div class="container-fluid">
            <span class="navbar-brand mb-0 h1">ERA</span>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav"
                aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav">
                    <li class="nav-item">
                        <a class="nav-link" aria-current="page" href="/">Home</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link active" href="/html/glossar.html">Glossar</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <div class="container">
        <h1>Glossar</h1>
        <p>Bei diesem Glossar handelt es sich um eine Erweiterung meiner Notizen zur Klausurvorbereitung. Es ist sehr
            wahrscheinlich, dass verschiedenste Fehler/Ungenauigkeiten in den Definitionen vorkommen. Diese kann man
            gerne als Issue <a
                href="https://github.com/hertelukas/era/issues/new?assignees=&labels=glossar&template=fehler-im-glossar.md&title=%5BBEGRIFF%5D"
                target="_blank" rel="noopener noreferrer">hier</a> melden, oder man erstellt einen neuen Pull-Request.
        </p>
        <table class="table table-striped">
            <thead>
                <tr>
                    <th scope="col">Begriff</th>
                    <th scope="col">Definition</th>
                    <th scope="col">Vorteile</th>
                    <th scope="col">Nachteile</th>
                </tr>
            </thead>
            <tr>
                <td>Adressierungsarten</td>
                <td>
                    <ul>
                        <li>Direkte A.</li>
                        <li>Registerindirekte A.</li>
                        <li>Registerindirekt mit Dekr/Inkr</li>
                        <li>Registerindirekt mit Displacement</li>
                        <li>Indizierte A.</li>
                        <li>Indizierte A. mit Skalierungsfaktor</li>
                        <li>Befehlszähler-relative A.</li>
                        <li>Speicherindirekte A.</li>
                    </ul>
                </td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td><a href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit"
                        target="_blank">ASIC</a></td>
                <td><b>Application Specific Integrated Circuit</b> Eine spezialisierte VLSI für einen bestimmten Zweck
                </td>
                <td>
                    <ul>
                        <li>Schneller</li>
                        <li>Energieeffizienter</li>
                        <li>Kleiner</li>
                        <li>Strahlungsresistent</li>
                        <li>...</li>
                    </ul>
                </td>
                <td>
                    <ul>
                        <li>Aufwendige Entwicklung</li>
                        <li>Teuere Entwicklung</li>
                        <li>Nicht vielseitig einsetzbar</li>
                    </ul>
                </td>
            </tr>
            <tr>
                <td>Befehlszyklus</td>
                <td>
                    <ol>
                        <li>Befehl holen</li>
                        <li>Dekodieren</li>
                        <li>Adresse evaluieren</li>
                        <li>Operand -> Rechnwerk</li>
                        <li>Befehl ausführen</li>
                        <li>In Accumulator/Register</li>
                        <li>BZ erhöhen</li>
                    </ol>
                </td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td>Behavioral Programming (HDL)</td>
                <td>Ähnlich sequentieller Programme. Beschreibt das Verhalten von Schaltungen.
                    Höchste Abstraktionsebene.</td>
                <td>
                    <ul>
                        <li>Einfach zu beschreiben/verstehen</li>
                    </ul>
                </td>
                <td>
                    <ul>
                        <li>Weniger Kontrolle</li>
                    </ul>
                </td>
            </tr>
            <tr>
                <td>Benutzermodus</td>
                <td>
                    <ul>
                        <li>Eingeschränkter Zugriff</li>
                        <li>Keine privilegierten Befehle wie z.B. Ein-/Ausgabe</li>
                        <li>Kein Zugriff auf Konfigurationsregister</li>
                    </ul>
                </td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td><a href="https://en.wikipedia.org/wiki/Endianness" target="_blank">Big-Endian</a></td>
                <td>Höchstes Byte wird an niedrigster Adresse gespeichert.
                    <p>
                    <h5>Beispiel</h5>
                    <b>0x01234567</b> wird folgend abgespeichert:
                    <table class="table table-sm table-striped">
                        <thead>
                            <tr>
                                <th scope="col">Adresse</th>
                                <th scope="col">Wert</th>
                            </tr>
                        </thead>
                        <tr>
                            <td>n+3</td>
                            <td>67</td>
                        </tr>
                        <tr>
                            <td>n+2</td>
                            <td>45</td>
                        </tr>
                        <tr>
                            <td>n+1</td>
                            <td>23</td>
                        </tr>
                        <tr>
                            <td>n</td>
                            <td>01</td>
                        </tr>
                    </table>
                    </p>
                </td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td><a href="https://en.wikipedia.org/wiki/Device_file#Block_devices" target="_blank"
                        rel="noopener noreferrer">Block Devices</a></td>
                <td>
                    <ul>
                        <li>Abstraktion im BS: Blöcke von Daten</li>
                        <li>Benutzer kann auf einzelne Daten zugriefen</li>
                        <li>Üblicherweise mit Dateisystem verbunden</li>
                        <li>z.B. Festplattenspeicher</li>
                    </ul>
                </td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td><a href="https://en.wikipedia.org/wiki/Branch_predictor" target="_blank"
                        rel="noopener noreferrer">Branch Prediction</a></td>
                <td>Vorhersage, ob Sprung genommen wird
                    Bei inkorrekter Vorhersage muss Pipeline neu aufgesetzt werden -> teuer
                </td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td>Cache Directory Protokolle</td>
                <td>Zentrales Verzeichnis, welches übersicht von Kopien in Caches hat. Heutiger Standard, kein Snooping
                    mehr.</td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td>Cache Index Bits</td>
                <td>Bestimmt die Cachezeile, in der Adresse sein kann.
                    32 Byte pro Cachezeile, Cache Grösse 32 KiB -> 1024 Cachezeilen -> 10 bit Index

                    Bei Cache Sets, wird das Set beschrieben
                </td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td>Cache Offset Bits</td>
                <td>Unterste Bits, bestimmen byte(?) index in einer Zeile.
                    32 Byte pro Cachezeile -> 5bit
                </td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td><a href="https://en.wikipedia.org/wiki/Bus_snooping" target="_blank" rel="noopener noreferrer">Cache
                        Snooping</a></td>
                <td>Gemeinsamer Bus zwischen Caches, alle Teilnehmer hören mit.
                    <ul>
                        <li>Teilnehmer passen laufend Cache-Inhalt an</li>
                        <li>MSI oder MESI Automat</li>
                    </ul>
                </td>
                <td>
                    <ul>
                        <li>Einfach zu implementieren</li>
                    </ul>
                </td>
                <td>
                    <ul>
                        <li>Busse skalieren schlecht</li>
                    </ul>
                </td>
            </tr>
            <tr>
                <td>Cache Tag Bit</td>
                <td>Oberste Bits, beschreiben welche Daten in Cachezeile sind</td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td>Capacity Cache Misses</td>
                <td>Der Speicherblock wäre auch verdrängt worden, wenn der Cache vollassoziativ wäre.</td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td><a href="https://en.wikipedia.org/wiki/Complex_instruction_set_computer" target="_blank">CISC</a>
                </td>
                <td><b>Complex Instruction Set Computer</b> Befehlssatz mit vielen Instruktionen, steht im Gegensatz zu
                    RISC.
                    Wird durch Mikroprogramme
                    realisiert.</td>
                <td>
                    <ul>
                        <li>Einfach Programmierbar</li>
                        <li>Geringer Speicherbedarf</li>
                    </ul>
                </td>
                <td>
                    <ul>
                        <li>Komplexe & langsame Implementierung</li>
                        <li>Komplexe & langsame Dekodierung</li>
                        <li>u.U ungenutzte Instruktionen</li>
                    </ul>
                </td>
            </tr>
            <tr>
                <td><a href="https://en.wikipedia.org/wiki/CMOS" target="_blank" rel="noopener noreferrer">CMOS</a></td>
                <td>

                    <div class="card mb-3" style="max-width: 540px;">
                        <div class="row g-0">
                            <div class="col-md-4">
                                <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/2f/CMOS_inverter.svg/1024px-CMOS_inverter.svg.png"
                                    class="img-fluid rounded-start" alt="CMOS Inverter">
                            </div>
                            <div class="col-md-8">
                                <div class="card-body">
                                    <p class="card-text"> <b>Complementary metal-oxide semiconductor</b> Besteht aus NPN
                                        und PNP Transistor. In der Abbildung ist ein CMOS Inverter zu sehen.</p>
                                    <p class="card-text"><small class="text-muted"><a
                                                href="https://commons.wikimedia.org/wiki/File:CMOS_inverter.svg">Abaddon1337</a>,
                                            <a href="https://creativecommons.org/licenses/by-sa/3.0">CC BY-SA 3.0</a>,
                                            via Wikimedia Commons</small>
                                    </p>
                                </div>
                            </div>
                        </div>
                    </div>
                </td>
                <td>
                    <ul>
                        <li>0 und 1 geschaltet</li>
                        <li>weniger Verlustleistung</li>
                        <li>weniger Hitzeentwicklung</li>
                        <li>weniger Störanfällig</li>
                    </ul>
                </td>
                <td></td>
            </tr>
            <tr>
                <td>Compulsory (cold) Cache Misses</td>
                <td>Erster Zugriff auf eine Adresse, nicht zu vermeiden</td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td>Conflict Cache Misses</td>
                <td>Speicherblock wurde verdrängt, da ein andere Block auf das gleiche Cache Set abgebildet wurde.</td>
                <td>
                    <ul>
                        <li>Unter Umständen vermeidbar</li>
                    </ul>
                </td>
                <td></td>
            </tr>
            <tr>
                <td><a href="https://en.wikipedia.org/wiki/Complex_programmable_logic_device" target="_blank"
                        rel="noopener noreferrer">CPLD</a></td>
                <td><b>Complex programmable logic device</b> Ein CPLD besteht aus mehreren SPLD Arrays welche
                    programmierbar miteinander verbunden sind.
                </td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td>Dataflow Programming (HDL)</td>
                <td>Boolesche Gleichungen, hierbei werden Automaten (Übergangsdiagramme) implementiert. Liegt zwischen
                    Behavioral und Structural.
                </td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td><a href="https://en.wikipedia.org/wiki/Binary_decoder" target="_blank"
                        rel="noopener noreferrer">Decoder</a></td>
                <td>
                    <p>n Eingänge zu 2<sup>n</sup> einzigartigen Ausgängen.
                        Nur ein Ausgang wird dabei auf 1 gesetzt.</p>

                    <div class="card" style="width: 20rem;">
                        <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/fc/Decoder_Example.svg/440px-Decoder_Example.svg.png"
                            class="card-img-top" alt="...">
                        <div class="card-body">
                            <p class="card-text">Ein 2 zu 4 Bit Decoder <br><small class="text-muted"><a
                                        href="https://commons.wikimedia.org/wiki/File:Decoder_Example.svg">BlueJester0101</a>,
                                    <a href="http://creativecommons.org/licenses/by-sa/3.0/">CC BY-SA 3.0</a>, via
                                    Wikimedia Commons</small></p>
                        </div>
                    </div>
                </td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td>Dennard Scaling</td>
                <td>Besagt, dass mit kleineren Transistoren auch die nötige Stromleistung zurück geht.
                    Endete ca 2005, da Prozessoren nicht mehr mehr Leistung benötigen, man setzt auf mehrere Kerne.
                </td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td>Direct I/O</td>
                <td>
                    <ul>
                        <li>Spezielle Befehle im Befehlssatz</li>
                        <li>Separate Adressen für I/O Geräte</li>
                        <li>Separate Bus für I/O Operationen</li>
                        <li>Prozessor kontrolliert E/A, wartet auf Daten</li>
                    </ul>
                </td>
                <td>
                    <ul>
                        <li>Schnell</li>
                    </ul>
                </td>
                <td>
                    <ul>
                        <li>Verschwendete Ressourcen</li>
                    </ul>
                </td>
            </tr>
            <tr>
                <td>Direct Mapped Cache</td>
                <td>Jede Adresse passt zu einer Cachezeile, die Index-Bits bestimmen die Lage der Daten im Cache.
                </td>
                <td>
                    <ul>
                        <li>Einfach zu berechnen, dadurch schnell</li>
                        <li>Einfach zu bauen</li>
                    </ul>
                </td>
                <td>
                    <ul>
                        <li>Unflexibel</li>
                        <li>Häufige Verdrängung von Cachezeilen</li>
                    </ul>
                </td>
            </tr>
            <tr>
                <td>DMA</td>
                <td><b>Direct Memory Access</b>
                    <ul>
                        <li>Prozessor beschreibt Transfer</li>
                        <li>Unabhängiger Kontroller führt ihn aus</li>
                        <li>Interrupt bei Abschluss</li>
                    </ul>
                </td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td><a href="https://en.wikipedia.org/wiki/Dynamic_random-access_memory" target="_blank"
                        rel="noopener noreferrer">DRAM</a></td>
                <td><b>Dynamic Random Access Memory </b>

                    <p>
                        Kondensator mit Information, hat eine Auswahlleitung und eine Bitleitung. Erfordert
                        regelmässigen DRAM Refresh.
                    </p>

                    <ul>
                        <li> Schreiben: Auswahlsignal setzen, 0 oder 1 an Bitleitung, lädt oder entlädt den Kondensator.
                        </li>
                        <li> Lesen: Auswahlsignal setzen, Wert zwischen 0 und 1 auf Bitleitung. Wenn 0 lädt sich der
                            Kondensator, Bitleitung geht auf 0 und umgekehrt.
                        </li>
                    </ul>
                </td>
                <td>
                    <ul>
                        <li>Einfach aufgebaut</li>
                        <li>Kann gross und günstig hergestellt werden</li>
                    </ul>
                </td>
                <td>
                    <ul>
                        <li>Grosser aktiver und passiver Energiebedarf</li>
                        <li>Langsamer Zugriff</li>
                    </ul>
                </td>
            </tr>
            <tr>
                <td><a href="https://en.wikipedia.org/wiki/Encoder_(digital)" target="_blank"
                        rel="noopener noreferrer">Encoder</a></td>
                <td>
                    <p>2<sup>n</sup> Eingänge werden binär kodiert auf n Ausgänge, so lange nur ein Eingang an ist.
                    </p>

                    <div class="card" style="width: 20rem;">
                        <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/4/4b/Encoder_diagram.svg/2880px-Encoder_diagram.svg.png"
                            class="card-img-top" alt="...">
                        <div class="card-body">
                            <p class="card-text">Ein 4 zu 2 Bit Decoder <br><small class="text-muted"><a
                                        href="https://commons.wikimedia.org/wiki/File:Encoder_diagram.svg">No
                                        machine-readable author provided. Booyabazooka assumed (based on copyright
                                        claims).</a>, <a href="http://creativecommons.org/licenses/by-sa/3.0/">CC BY-SA
                                        3.0</a>, via Wikimedia Commons</small></p>
                        </div>
                    </div>
                </td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td><a href="https://en.wikipedia.org/wiki/Ethernet" target="_blank"
                        rel="noopener noreferrer">Ethernet</a></td>
                <td>Am weitesten verbreitete Familie von Netztechnologien
                    <ul>
                        <li> Früher Shared Medium -> Quasi ein Bus </li>
                        <li> Heute Point to Point (Switched Network) </li>
                    </ul>
                </td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td>Exceptions</td>
                <td>
                    <ul>
                        <li>Ausgelöst von einer Operation im Programm (von innen)</li>
                        <li>Synchron</li>
                        <li>Beispiel: Nicht erlaubte Befehle (z.B. divide by zero)</li>
                    </ul>
                </td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td>Exklusiver Cache</td>
                <td>Jeder Speicherblock existiert nur einmal in der gesamnten Cachehierarchie. Häufig bei AMD verwendet.
                </td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td><a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array" target="_blank"
                        rel="noopener noreferrer">FPGA</a></td>
                <td><b>Field Programmable Gate Array</b>
                    <ul>
                        <li>Emulation von beliebigen Schaltungen</li>
                        <li>Einfacher als CPLDs</li>
                    </ul>
                </td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td><a href="https://en.wikipedia.org/wiki/Graphics_processing_unit" target="_blank"
                        rel="noopener noreferrer">GPU</a></td>
                <td>Eine <b>Graphics Processing Unit</b> ist eine VLSI welcher auf extremes SIMD setzt.</td>
                <td>
                    <ul>
                        <li>Reduziert die Komplexität des Prozessors</li>
                        <li>Erhöhte Energieeffizienz</li>
                    </ul>
                </td>
                <td>
                    <ul>
                        <li>Verrignerte Softwareflexibilität (Muss SIMD nutzen)</li>
                        <li>Zusätzlicher Programmieraufwand</li>
                    </ul>
                </td>
            </tr>
            <tr>
                <td>Gründe für Moduswechsel</td>
                <td>
                    <ul>
                        <li>durch speziellen Befehl </li>
                        <li>durch Interrupts/Exceptions</li>
                    </ul>
                </td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td>Hardware Prefetching</td>
                <td>Hardware untersucht Zugriffsadressen -> Erkennt Muster -> Liest zukünftige Daten.
                    Beispiel: Prefetch Folgezeile oder Strided Prefetcher</td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td>Hardware Thread</td>
                <td>
                    <ul>
                        <li>Ausführungseinheit in Hardware mit BZ</li>
                        <li>Getrennte Registersätze</li>
                        <li>Führt eine Programmsequenz aus</li>
                    </ul>

                    Wird oft auch Kern genannt
                </td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td><a href="https://en.wikipedia.org/wiki/Hardware_description_language" target="_blank"
                        rel="noopener noreferrer">HDL</a></td>
                <td><b>Hardware Description Language</b> Beschreibung einzelner Komponenten für die Entwicklung von
                    FPGAs
                </td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td>Inklusiver Cache</td>
                <td>Alle Speicherblöcke sind auch in dem nächst grösseren Cache enthalten. Häufig bei Intel verwendet.
                </td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td>Interrupt-driven I/O</td>
                <td>Prozessor löst Zugriff aus, E/A arbeitet alleine, Abschluss wird durch Interrupt signalisiert. Steht
                    im Gegensatz zu Direct I/O</td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td>Interrupts</td>
                <td>
                    <ul>
                        <li>Erlauben dem Prozessor auf externe( Tastaur z.B.), asynchrone Ereignisse zu reagieren</li>
                        <li>Können ignoriert werden</li>
                    </ul>
                </td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td><a href="https://en.wikipedia.org/wiki/Endianness" target="_blank">Little-Endian</a></td>
                <td>Höchstes Byte steht an höchster Adresse. Wird von Intel verwendet und wird deutlich häufiger
                    verwendet.
                    <p>
                    <h5>Beispiel</h5>
                    <b>0x01234567</b> wird folgend abgespeichert:
                    <table class="table table-sm table-striped">
                        <thead>
                            <tr>
                                <th scope="col">Adresse</th>
                                <th scope="col">Wert</th>
                            </tr>
                        </thead>
                        <tr>
                            <td>n+3</td>
                            <td>01</td>
                        </tr>
                        <tr>
                            <td>n+2</td>
                            <td>23</td>
                        </tr>
                        <tr>
                            <td>n+1</td>
                            <td>45</td>
                        </tr>
                        <tr>
                            <td>n</td>
                            <td>67</td>
                        </tr>
                    </table>
                    </p>
                </td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td>
                    Load/Store-Architektur</td>
                <td>Auch Register-Register-Maschine genannt.
                    <ul>
                        <li>Speicherzugriffe explizit als Maschinenbefehle</li>
                        <li>Arithmetik nur aus Registern</li>
                        <li>Registerindirekte Adressierung mit 12bit oder Register Offset</li>
                        <li>Unterstützt Prädekrement/Postinkrement</li>
                    </ul>
                </td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td><a href="https://en.wikipedia.org/wiki/Lookup_table" target="_blank"
                        rel="noopener noreferrer">LUT</a></td>
                <td><b>Lookup Table</b>
                    Zentrales Element eines Logikblocks in einem FPGA.
                    <ul>
                        <li>3-6bit Eingang</li>
                        <li>1 bit Ausgang</li>
                        <li>Beliebige Schaltung</li>
                        <li>Optional mit Flipflop</li>
                    </ul>

                    Kann z.B. als SRAM realisiert werden.
                </td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td><a href="https://en.wikipedia.org/wiki/Mealy_machine" target="_blank"
                        rel="noopener noreferrer">Mealy Automat</a></td>
                <td>Ein deterministischer endlicher Automat, dessen Ausgabe von seinem Zustand und seiner Eingabe
                    abhängt.</td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td>Mehrkern Architektur</td>
                <td>Mehrere HW Threads in einem System
                    <ul>
                        <li>getrennte Kerne</li>
                        <li>Replikation Leit & Rechenwerk</li>
                        <li>Gemeinsamer Speicher</li>
                        <li>Meist gemeinsames E/A Werk</li>
                        <li>Voller Speed-Up (Gegensatz zu SMT)</li>
                    </ul>
                </td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td>Memory Mapped I/O</td>
                <td>
                    <ul>
                        <li>Ansprechen der Geräte über Speicherbereiche</li>
                        <li>Speicher Teil des normalen Speicherbereichs</li>
                        <li>Kontrolliert duch virtuelle Speicherverwaltung</li>
                        <li>Heutiger Standard</li>
                    </ul>
                </td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td>Memory Mountain</td>
                <td>
                    <ul>
                        <li>Umso grösser der Speicher -> Umso langsamer</li>
                        <li>Umso grösser die Strides -> Umso langsamer</li>
                    </ul>
                </td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td>Mengenassoziativer Cache</td>
                <td>
                    <ul>
                        <li>Jede Adresse kann auf einen Teil der Cache Zeilen abgebildet werden</li>
                        <li>Mehrere Cache-Sets / Reduzierte Zahl von Index bits</li>
                    </ul>
                    Beispiel: 4-way associative = 4 Zeilen pro Cacheset
                </td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td><a href="https://en.wikipedia.org/wiki/MESI_protocol" target="_blank" rel="noopener noreferrer">MESI
                        Protokoll</a></td>
                <td>MSI, aber mit Exclusive Zustand. <br>
                    Exclusive: Wert in einem Cache, unverändert</td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td>MIMD</td>
                <td><b>Multiple Instruction Multiple Data</b>
                    n Rechenwerke, n Leitwerke <br>
                    -> Parallele Systeme
                    <ul>
                        <li>Mehrere HW Threads, prinzipiell unkoordiniert, keine direkten abhängigkeiten, parallele
                            Ausführung</li>
                        <li>Gemeinsamer Speicher, sonst getrennte Maschinen</li>
                    </ul>
                </td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td>Misaligned Data</td>
                <td>
                    Ein Speicherzugriff ist aligned wenn die Daten, auf welche zugegriffen wird, n Bytes lang sind und
                    das einzelne Datum an einer Adresse liegt welche durch n teilbar ist. Bytes sind somit immer
                    aligned.
                    Ist die Eigenschaft nicht erfüllt, sind die Daten misaligned.
                </td>
                <td>
                    <ul>
                        <li>Lückenlose Nutzung des Speichers bei Mischung verschiedener Datenformate</li>
                        <li>Bessere Kompatibilität zu älteren ISAs</li>
                    </ul>
                </td>
                <td>
                    <ul>
                        <li>Ggf. zusätzliche Speicherzugriffe notwendig</li>
                        <li>Höherer Hardware-Aufwand erforderlich</li>
                    </ul>
                </td>
            </tr>
            <tr>
                <td><a href="https://en.wikipedia.org/wiki/Memory_management_unit" target="_blank"
                        rel="noopener noreferrer">MMU</a></td>
                <td><b>Memory management unit</b>
                    Separate Hardware auf der CPU, welche virtuelle Adressen via LUT in Physikalische übersetzt.</td>
            </tr>
            <tr>
                <td><a href="https://en.wikipedia.org/wiki/Moore_machine" target="_blank"
                        rel="noopener noreferrer">Moore Automat</a></td>
                <td>Ein endlicher Automat, dessen Ausgabe ausschließlich von seinem Zustand abhängt.</td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td><a href="https://en.wikipedia.org/wiki/MSI_protocol" target="_blank" rel="noopener noreferrer">MSI
                        Protokoll</a></td>
                <td>Jede Cachezeile muss ihren Status mitverfolgen.
                    <ul>
                        <li>Modified: Cachezeile lokal geändert, Speicher nicht koheränt</li>
                        <li>Shared: Wert in mindestens einem Cache, kohärent</li>
                        <li>Invalid: Cacheblock nicht gültig oder veraltet</li>
                    </ul>
                </td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td><a href="https://en.wikipedia.org/wiki/Multiplexer" target="_blank"
                        rel="noopener noreferrer">Multiplexer</a></td>
                <td>Wid genutzt um Daten auszuwählen. Es wird anhand eines Selector- Eingangs ein Eingang ausgewählt und
                    dieser weitergeleitet zum Ausgang.
                    <br>
                    <div class="card" style="width: 20rem;">
                        <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/1/16/Multiplexer2.svg/2880px-Multiplexer2.svg.png"
                            class="card-img-top" alt="Multiplexer">
                        <div class="card-body">
                            <p class="card-text">2-zu-1 Multiplexer. Entspricht einem kontrollierten Switch.<br><small
                                    class="text-muted"><a
                                        href="https://commons.wikimedia.org/wiki/File:Multiplexer2.svg">CaesarIII</a>,
                                    <a href="https://creativecommons.org/licenses/by-sa/3.0">CC BY-SA 3.0</a>, via
                                    Wikimedia Commons</small></p>
                        </div>
                    </div>
                </td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td>Multithreading</td>
                <td>Mehrere HW Threads in einem Prozessorkern.
                    <ul>
                        <li>Einzelner BZ und Register</li>
                        <li>Ressourcen geteilt</li>
                        <li>Umschalten nach x Takten</li>
                        <li>Meist Fork/Join (Master startet einen neuen Thread) (siehe Java Threads)</li>
                    </ul>
                </td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td>NAND Flash</td>
                <td>Bei der Verbindung zwischen der Bit-Line und dem Word-Line handet es sich um ein NAND Gate. Wird in
                    SSDs und USB Sticks verwendet.</td>
                <td>
                    <ul>
                        <li>Schnell</li>
                        <li>Klein</li>
                        <li>Geeignet für Speicher</li>
                        <li>Zugriff über Blöcke</li>
                    </ul>
                </td>
                <td>
                    <ul>Begrenzte Anzahl von Löschvorgängen</ul>
                </td>
            </tr>
            <tr>
                <td>Nebenläufige und Parallele Programme</td>
                <td>Nebenläufig
                    <ul>
                        <li>Getrennte Aufgaben</li>
                        <li>Lose Kooperation</li>
                        <li>Bsp. GUI, E/A</li>
                    </ul>

                    Parallel
                    <ul>
                        <li>Gemeinsame Aufgabe</li>
                        <li>Enge Kopplung</li>
                        <li>Bsp. numerische Simulation, Suchalgorithmen</li>
                    </ul>
                </td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td><a href="https://en.wikipedia.org/wiki/Network_interface_controller" target="_blank"
                        rel="noopener noreferrer">NIC</a></td>
                <td><b>Network Interface Card</b> Komponente im Computer die den Computer mit einem Netzwerk verbindet.
                </td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td>Non-uniform Memory Access</td>
                <td>
                    <ul>
                        <li>Speicher ist verteilt über mehrere Kerne</li>
                        <li>Inter-Kern Netzwerk</li>
                    </ul>
                </td>
                <td>
                    <ul>
                        <li>Schnelle lokale Zugriffe</li>
                    </ul>
                </td>
                <td>
                    <ul>
                        <li>Datenplatzierung wichtig</li>
                    </ul>
                </td>
            </tr>
            <tr>
                <td>NOR Flash</td>
                <td>Bei der Verbindung zwischen der Bit-Line und dem Word-Line handet es sich um ein NOR Gate. Gut für
                    BIOS und andere Boot Medien.</td>
                <td>
                    <ul>
                        <li>Zuverlässiger als NAND Flash</li>
                        <li>Einzelzugriff</li>
                    </ul>
                </td>
                <td></td>
            </tr>
            <tr>
                <td><a href="https://en.wikipedia.org/wiki/Bipolar_junction_transistor#NPN" target="_blank"
                        rel="noopener noreferrer">NPN Transistor</a></td>
                <td>NPN ist ein Arbeitskontakt -> Leitend, falls Strom anliegt</td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td><a href="https://en.wikipedia.org/wiki/Out-of-order_execution" target="_blank"
                        rel="noopener noreferrer">Out-of-Order Execution</a></td>
                <td>Auch dynamisches Scheduling genannt.
                    Unabhängige Instruktionen können ausgeführt werden, obwohl vorherige Operationen blockiert sind,
                    trotzdem transparent</td>
                <td>
                    <ul>
                        <li>Bessere Nutzung der Ressourcen</li>
                        <li>Bessere Nutzung von Parallelität</li>
                        <li>Möglichkeit mehrere gleiche Befehle anzustossen</li>
                    </ul>
                </td>
                <td>
                    <ul>
                        <li>Erhöhte Buchhaltunkgskomplexität</li>
                        <li>Speicher muss konsistent gehalten werden -> Reorder Buffers notwendig</li>
                    </ul>
                </td>
            </tr>
            <tr>
                <td><a href="https://en.wikipedia.org/wiki/Programmable_Array_Logic" target="_blank" rel="noopener noreferrer">PAL</a> / <a href="https://en.wikipedia.org/wiki/Generic_array_logic" target="_blank" rel="noopener noreferrer">GAL</a></td>
                <td><b>Programmable/General Array Logic</b> UND programmierbar, ODER fest
                    <ul>
                        <li> PAL -> Non-Volatile</li>
                        <li> GAL -> Volatile</li>
                    </ul>
                </td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td>Physically Indexed Cache</td>
                <td>Cache nach MMU, Cache arbeitet mit physikalischen Adressen
                </td>
                <td>
                    <ul>
                        <li>Überlebt Prozesswechsel</li>
                        <li>Gut für grosse Caches</li>
                    </ul>
                </td>
                <td>
                    <ul>
                        <li>Jeder Zugriff durch MMU</li>
                    </ul>
                </td>
            </tr>
            <tr>
                <td>Pipeline Control Hazard</td>
                <td>Verursacht durch Sprünge, da Befehl unbekannt</td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td>Pipeline Data Hazard</td>
                <td>Datenabhängigkeiten nicht erfüllt</td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td>Pipeline Structural Hazard</td>
                <td>Ressourcenprobleme in der Hardware</td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td><a href="https://en.wikipedia.org/wiki/Pipeline_(computing)" target="_blank" rel="noopener noreferrer">Pipelining</a></td>
                <td>Bearbeitung eines Objekts wird in Teilschritte zerlegt und sequentiell ausgeführt. Die Phasen werden
                    für verschiedene Objekte überlappend abgearbeitet. <br>
                    Kann sowohl in Software als auch in Hardware umgesetzt werden.</td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td><a href="https://en.wikipedia.org/wiki/Programmable_logic_array" target="_blank" rel="noopener noreferrer">PLA</a></td>
                <td><b>Programmable Logic Array</b> Für DNFs, UND gefolgt von ODER, beides programmierbar.</td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td><a href="https://en.wikipedia.org/wiki/Programmable_logic_device" target="_blank" rel="noopener noreferrer">PLD</a></td>
                <td><b>Programmable Logic Device</b>Allgemeiner Begriff der alle programmierbaren Schaltungen beschreibt
                    wie SPLDs, CPLDs, und FPGAs.</td>
                <td>
                    <ul>
                        <li>Einfach Aufgebaut</li>
                        <li>Geeignet für "Rapid Prototyping"</li>
                    </ul>
                </td>
                <td>
                    <ul>
                        <li>Langsamer & Kleiner als ASICs</li>
                    </ul>
                </td>
            </tr>
            <tr>
                <td><a href="https://en.wikipedia.org/wiki/Programmable_ROM" target="_blank" rel="noopener noreferrer">PROM</a></td>
                <td><b>Programmable Read-Only Memory</b> UND fest, ODER programmierbar.
                    <br>
                    EPROM -> Erasable PROM, mit UV Licht
                    <br>
                    EEPROM -> Electrcially EPROM
                </td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td><a href="https://en.wikipedia.org/wiki/Reduced_instruction_set_computer" target="_blank">RISC</a>
                </td>
                <td>Reduced Instruction Set Computer. Hoch optimierter, minimalistischer Befehlssatz mit nur wenig
                    unterschiedlichen Instruktionen. Steht
                    im Gegensatz zu CISC. Wird durch feste Verdrahtung realisiert.</td>
                <td>
                    <ul>
                        <li>Einfache Implementierung</li>
                        <li>Effiziente Implementierung</li>
                        <li>Schnelle Implementierung</li>
                    </ul>
                </td>
                <td>
                    <ul>
                        <li>Schwierigere Programmierbarkeit (Wird aber durch Compiler abstrahiert)</li>
                    </ul>
                </td>
            </tr>
            <tr>
                <td><a href="https://en.wikipedia.org/wiki/Read-only_memory" target="_blank" rel="noopener noreferrer">ROM</a></td>
                <td><b>Read Only Memory</b> UND fest, ODER fest, dementsprechend nicht programmierbar.</td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td><a href="https://en.wikipedia.org/wiki/SIMD" target="_blank" rel="noopener noreferrer">SIMD</a></td>
                <td><b>Single Instruction Multiple Data</b> n Rechenwerke, 1 Leitwerk
                    <br>
                    -> Pipelines, Vectors, GPUs (Moderne GPUs sind MIMD, mehrere extreme SIMD Blöcke)
                    <br>
                    Mehrere Daten werden durch einen Maschinenbefehl geleitet.
                </td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td><a href="https://en.wikipedia.org/wiki/Simultaneous_multithreading" target="_blank" rel="noopener noreferrer">Simultaneous Multithreading (SMT)</a></td>
                <td>Gleichzeitige Nutzung von Ressourcen, passt zu OoO und Superskalarität.</td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td>SISD</td>
                <td><b>Single Instruction Single Data</b> 1 Rechenwerk, 1 Leitwerk <br>

                    -> Seq. Verarbeitung von Neumann</td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td>Software Prefetching</td>
                <td>Explizite Instruktionen welche Daten in den Cache laden.
                </td>
                <td>
                    <ul>
                        <li>Unregelmässige Zugriffe können verbessert werden</li>
                        <li>Generell ist Software Prefetching nicht blockierend und erzeugt keine Ausnahmen</li>
                    </ul>
                </td>
                <td>
                    <ul>
                        <li>Benötigt Codeänderungen und ist dementsprechend nicht transparent</li>
                    </ul>
                </td>
            </tr>
            <tr>
                <td>Spin-Locks</td>
                <td>Busy waiting -> Siehe EIDI</td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td><a href="https://en.wikipedia.org/wiki/Simple_programmable_logic_device" target="_blank" rel="noopener noreferrer">SPLD</a></td>
                <td><b>Simple Programmable Logic Device</b> Schaltnetz aus einem UND und einem ODER Array. Beide evtl.
                    programmierbar</td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td><a href="https://en.wikipedia.org/wiki/Static_random-access_memory" target="_blank" rel="noopener noreferrer">SRAM</a></td>
                <td>Static Random Access Memory

                    Nutzung in Register & Caches
                    Prinzip ähnlich zu Latch.
                    Schreiben: Bit auf 1, Nicht Bit auf 0, Select auf 1, Inverter pegeln sich ein
                    Lesen: Bit auf 1, Nicht Bit auf 1, Inverter ziehen somit einen Ausgang auf 0, Spannungsabfall wird
                    gemessen</td>
                <td>
                    <ul>
                        <li>Behält Wert solange Strom</li>
                        <li>Sehr schnell (1 - 30 ns)</li>
                        <li>Unempfindlich</li>
                    </ul>
                </td>
                <td>
                    <ul>
                        <li>Relativ gross & teuer</li>
                        <li>Grosser Energiebedarf wenn aktiv</li>
                    </ul>
                </td>
            </tr>
            <tr>
                <td>Stream Devices</td>
                <td>
                    <ul>
                        <li>Abstraktion im BS: Reihe/Strom von Bytes</li>
                        <li>Zugriff meist sequentiell</li>
                        <li>z.B. Tastatur, Serielle Schnittstellen</li>
                    </ul>
                </td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td>Structural Programming (VHDL)</td>
                <td>Verbundenen einzelne Komponenten, beschreibt einzelene Schaultungen welche hierarchisch Verbunden
                    werden.</td>
                <td>
                    <ul>
                        <li>Volle Kontrolle</li>
                    </ul>
                </td>
                <td>
                    <ul>
                        <li>Aufwendig</li>
                    </ul>
                </td>
            </tr>
            <tr>
                <td>Superskalarprinzip</td>
                <td>Ein superskalarer Prozessor verfügt im Vergleich zu einem Prozessor mit sequentieller Pipeline über
                    die n-fache Anzahl von Funktionseinheiten, Datenpfaden, Dekodierern, etc. -> n Befehle können
                    gleichzeitig ausfgeführt werden.</td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td>Systemmodus</td>
                <td>
                    <ul>
                        <li>Voller (=privilegierter) Zugriff auf alle Rechnerkomponenten</li>
                        <li>Für das Betriebssystem</li>
                    </ul>
                </td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td><a href="https://en.wikipedia.org/wiki/Translation_lookaside_buffer" target="_blank" rel="noopener noreferrer">TLB</a></td>
                <td><b>Translation Lookaside Buffer</b> Kleiner Cache mit Page Table Einträgen in der MMU um
                    Addreessübersetzung zu beschleunigen</td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td><a href="https://en.wikipedia.org/wiki/Uniform_memory_access" target="_blank" rel="noopener noreferrer">Uniform Memory Access (UMA)</a></td>
                <td>
                    <ul>
                        <li>Zentraler gemeinsamer Speicher</li>
                        <li>Zugriffe haben gleiche Latenz (ausser durch Caches)</li>
                        <li>Busse oder Crossbar</li>
                    </ul>
                </td>
                <td></td>
                <td></td>
            </tr>

            <tr>
                <td>Virtually Indexed Cache</td>
                <td>Cache vor MMU, Cache arbeitet also mit virtuellen Adressen.</td>
                <td>
                    <ul>
                        <li>Direkter Zugang zu Cache ohne Übersetzung</li>
                        <li>Gut für kleine Caches</li>
                    </ul>
                </td>
                <td>
                    Mehrere Prozesse verwenden die gleichen virtuellen Adressen. <br>
                    Lösungen:
                    <ul>
                        <li>Cache löschen bei Prozesswechsel </li>
                        <li> Im Tag wird auch die PID gespeichert</li>
                    </ul>
                    Beide Lösungen führen zur Verlangsamung und erhöhter Aufwendigkeit.
                </td>
            </tr>
            <tr>
                <td><a href="https://en.wikipedia.org/wiki/Very_long_instruction_word" target="_blank" rel="noopener noreferrer">VLIW</a></td>
                <td><b>Very Long Instruction Word</b> Mehrere Instruktionen in einem Befehl, spezielle Prozessoren.
                </td>
                <td>
                    <ul>
                        <li>Explizite Abhängigkeiten -> Einfachere Hardware</li>
                        <li>Explizites Scheduling -> Einfachere Hardware</li>
                    </ul>
                </td>
                <td>
                    <ul>
                        <li>Komplexe, nicht kompatible ISAs</li>
                        <li>Beruht auf Fähigkeiten des Compilers</li>
                    </ul>
                </td>
            </tr>
            <tr>
                <td><a href="https://en.wikipedia.org/wiki/Very_Large_Scale_Integration" target="_blank" rel="noopener noreferrer">VLSI</a></td>
                <td><b>Very-large-scale Integration</b> ist eine Herstellungstechnologie bei der viele Tausende
                    Transistoren in einen einzelnen Chip integriert werden.</td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td>Volatile</td>
                <td>Erneut Programmierbar</td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td>Voll assoziativer Cache</td>
                <td>Jede Adresse kann auf jede Cache Zeile abgebildet werden, es existiert nur ein "Cache Set".
                </td>
                <td>
                    <ul>
                        <li>Keine Index bits</li>
                        <li>Grösste Flexibilität</li>
                    </ul>
                </td>
                <td>
                    <ul>
                        <li>Komplex</li>
                    </ul>
                </td>
            </tr>
            <tr>
                <td><a href="https://en.wikipedia.org/wiki/Von_Neumann_architecture" target="_blank" rel="noopener noreferrer">Von-Neumann Architekturkonzept</a> </td>
                <td>
                    <ol>
                        <li>Strukturunabhängigkeit des Rechners</li>
                        <li>4 Werke</li>
                        <li>Sequentiell, Befehle nacheinander gespeichert & ausgeführt</li>
                        <li>Binär</li>
                        <li>Programme & Daten in einem Speicher</li>
                        <li>Speicher besteht aus Zeilen fester Grösse</li>
                        <li>Sprünge möglich</li>
                    </ol>
                </td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td>Yielding Locks</td>
                <td>Falls Lock vergeben, gebe Thread ab</td>
                <td></td>
                <td></td>
            </tr>
        </table>

        <h2>Vergleiche</h2>
        <table class="table table-striped">
            <thead>
                <tr>
                    <th scope="col">Begriff</th>
                    <th scope="col">Vergleich</th>
                    <th scope="col">Gemeinsamkeiten</th>
                </tr>
            </thead>
            <tr>
                <td><b>FPGA</b>
                    <ul>
                        <li>Rekonfigurierbar</li>
                        <li>Günstig</li>
                        <li>Schnelle Entwicklung ("Time to Market")</li>
                    </ul>
                </td>
                <td><b>ASIC</b>
                    <ul>
                        <li>Deutlich schneller</li>
                        <li>Kann für spezielle Einsatzgebiete gebaut werden</li>
                        <li>Hoch spezialisiert</li>
                    </ul>
                </td>
                <td></td>
            </tr>
            <tr>
                <td><b>FPGA</b>
                    <ul>
                        <li>Schneller</li>
                        <li>Höherer Durchsatz</li>
                        <li>Bessere Vorhersagbarkeit</li>
                    </ul>
                </td>
                <td><b>CPU</b>
                    <ul>
                    </ul>
                </td>
                <td></td>
            </tr>
            <tr>
                <td><b>Pipelining</b>
                    <ul>
                        <li>Mehrere verschiedene Stufen gleichzeitig</li>
                    </ul>
                </td>
                <td><b>Superskalar</b>
                    <ul>
                        <li>Mehrere gleiche Einheiten gleichzeitig</li>
                    </ul>
                </td>
                <td>Beide erlauben Parallelität, ergänzen sich</td>
            </tr>
            <tr>
                <td><b>Thread</b>
                    <ul>
                        <li>Eng gekoppelt</li>
                        <li>Gemeinsamer Adressraum</li>
                        <li>Schnelle Umschaltung</li>
                        <li>Gemeinsame Ressourcen (Dateien...)</li>
                    </ul>
                </td>
                <td><b>Prozesse</b>
                    <ul>
                        <li>Lose gekoppelt</li>
                        <li>Getrennte Adressräume</li>
                        <li>Bessere Isolierung</li>
                    </ul>
                </td>
                <td></td>
            </tr>
        </table>
    </div>


    <footer class="footer">
        <span class="text-muted">Contribute on <a href="https://github.com/hertelukas/era" target="_blank"
                rel="noopener noreferrer"> <i class="fab fa-github"></i></a></span>
    </footer>
</body>

</html>
